//
//  kvmeta.hpp
//
//  Created by MNN on 2025/04/08.
//  Copyright Â© 2018, Alibaba Group Holding Limited
//

#ifndef KVMETA_hpp
#define KVMETA_hpp

#include <cstdint>
#include <vector>

namespace MNN {
using namespace Express;
namespace Transformer {

struct KVMeta {
    enum {
        NoChange,
        PendingWrite,
        PendingRead
    } file_operation;
    size_t block = 4096;
    size_t previous = 0;
    size_t remove = 0;
    int* reserve = nullptr;
    int n_reserve = 0;
    size_t add = 0;
    std::string file_name = "";
    int file_flag = NoChange;
    int seqlen_in_disk = 0;
    int layer_index = 0;
    int layer_nums = 0;

    // H2O runtime configuration (set by llm config).
    int h2o_enable = 0;
    int h2o_layer_start = 2;
    int h2o_layer_end = -1;
    int h2o_block_tokens = 64;
    int h2o_sink_tokens = 32;
    int h2o_recent_tokens = 256;
    float h2o_target_keep_ratio = 0.50f;
    int h2o_target_mode = 1; // 0:static keep ratio, 1:adaptive by target lossy ratio
    float h2o_target_lossy_ratio = 3.0f;
    float h2o_ema_alpha = 0.90f;
    int h2o_update_interval = 16;
    int h2o_trigger_min_tokens = 512;
    int h2o_log_stats = 0;
    int h2o_lossless_enable = 0;
    int h2o_lossless_codec = 0; // 0:none 1:gear_delta
    int h2o_lossless_scope = 1; // 0:none 1:front_n 2:h2o_kept
    int h2o_lossless_front_n = 2;
    int h2o_lossless_runtime_enable = 0;
    int h2o_lossless_runtime_mode = 0; // 0:probe(sample), 1:full, 2:store(experimental)
    int h2o_lossless_block_tokens = 128;
    int h2o_lossless_hot_recent_tokens = 256;
    int h2o_lossless_hot_sink_tokens = 16;
    std::string h2o_lossless_codec_runtime = "fp16_gear_predictive_v3";
    std::string h2o_lossless_predictors_k = "raw,delta_seq,xor_seq,pair_delta";
    std::string h2o_lossless_predictors_v = "raw,delta_seq,xor_seq";
    int h2o_lossless_async_threads = 1;
    int h2o_lossless_max_queue = 256;
    int h2o_lossless_decode_cache_blocks = 64;
    int h2o_lossless_strict_roundtrip_check = 0;
    int h2o_in_decode = 0;

    // Next-step pending compact plan generated by H2O.
    size_t h2o_pending_remove = 0;
    int* h2o_pending_reserve = nullptr;
    int h2o_pending_n_reserve = 0;
    int h2o_pending_plan_ready = 0;

    // Runtime stats.
    float h2o_keep_ratio = 1.0f;
    float h2o_lossy_ratio = 1.0f;
    float h2o_lossless_ratio = 1.0f;
    float h2o_target_keep_effective = 1.0f;
    float h2o_floor_keep_by_recent_sink = 1.0f;
    float h2o_block_quantized_keep = 1.0f;
    int64_t h2o_evict_us = 0;
    int64_t h2o_codec_us = 0;
    uint64_t h2o_lossless_raw_bytes = 0;
    uint64_t h2o_lossless_compressed_bytes = 0;
    uint64_t h2o_lossless_decompressed_bytes = 0;
    int64_t h2o_lossless_compress_us = 0;
    int64_t h2o_lossless_decompress_us = 0;
    int64_t h2o_lossless_queue_depth_peak = 0;
    int64_t h2o_lossless_fallback_count = 0;
    int h2o_last_evict_tokens = 0;
    int h2o_total_evict_tokens = 0;

    std::vector<int> reserveHost;
    void sync();
};

}
}
#endif // KVMATE_hpp
